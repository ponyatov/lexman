\secrel{Синтаксис и реализация языка \bi}\label{bisyntax}\secdown

\input{script/comment}

\secrel{AST: абстрактный символьный тип}\label{symbol}

Язык \bi\ построен на символьных вычислениях: интерпретации структур данных,
состоящих из элементов \term{AST}\note{[A]bstract [S]yntax [T]ree}.
Идеология "программа есть данные"\ была взята из \lisp а, и дополнена
\py-подобным синтаксисом и динамической объектной системой а-ля \st.

\begin{framed}
Применение в основе иерархии объектов языка \bi\ \term{виртуального}\ базового
класса позволяет работать с объектами классов-наследников, используя указатели
\verb|sym*|\ на базовый класс. 
\end{framed}

\lst{hpp.hpp}{tmp/hpp.sym}{c++}

\begin{tabular}{l l}
\verb|tag| & тэг, тип/класс объекта \\
\verb|val| & символьное значение объекта \\
sym(string T,string V) & создает символьный объект из строк для тэга
 и начального значения \\
\hline
\verb|nest[ ]| & каждый AST-объект может содержать вложенные объекты \\
push(sym*) & втолкнуть объект в \verb|next[]|\ как в стек \\
sym* pop() & взять объект из стека \\ 
\hline
dump() & вывод дампа объекта, включая вложенные, в древовидной форме \\
pad(n) & выравнивание пробелами слева при работе \verb|dump()| \\
tagval() & возвращает минимальное текстовое представление 
объекта в форме <tag:val> \\
\end{tabular}

\bigskip
AST-объект поддерживает хранение вложенных элементов, что позволяет легко
реализовать хранение древовидиных структур, характерных для программ символьных
вычислений и трансляторов. 

Функции \verb|push/pop|\ используются при определении пользовательских 
анонимных и именованных функций \ref{lamdba}\ в стиле языка \forth.  

\secrel{Скалярные типы}\secdown

\secrel{Символ <sym:symbol>}

\lst{lpp.lpp}{tmp/lpp.sym}{c++}
\lst{hpp.hpp}{tmp/hpp.ssm}{c++}
\lst{cpp.cpp}{tmp/cpp.ssm}{c++}

\secrel{Строка <str:'строка'>}

Работа лексера по разбору строк описана в \ref{lexstring}

\lst{lpp.lpp}{tmp/lpp.str}{c++}
\lst{ypp.ypp}{tmp/ypp.str}{c++}
\lst{hpp.hpp}{tmp/hpp.str}{c++}

Дамп строки выводится с кавычками:

\lst{cpp.cpp}{tmp/cpp.str}{c++}

\secrel{Числа}

Работа лексера по разбору чисел описана в \ref{lexnumbers}

\lst{ypp.ypp}{tmp/ypp.num}{c++}

\secrel{Int: целое число <int:1234>}

\lstx{script.bI}{tmp/bi.int}

\lst{lpp.lpp}{tmp/lpp.int}{c++}

\lst{hpp.hpp}{tmp/hpp.int}{c++}

\secrel{Hex: машинное шестнадцатеричное <hex:0x12AF> }

\lstx{script.bI}{tmp/bi.hex}

\lst{lpp.lpp}{tmp/lpp.hex}{c++}

\lst{hpp.hpp}{tmp/hpp.hex}{c++}

\secrel{Bin: машинное двоичное <bin:0b1101>}

\lstx{script.bI}{tmp/bi.bin}

\lst{lpp.lpp}{tmp/lpp.bin}{c++}

\lst{hpp.hpp}{tmp/hpp.bin}{c++}

\secrel{Num: число с плавающей точкой <num:1.23> <num:-3e+5>}

\lstx{script.bI}{tmp/bi.num}

\lst{lpp.lpp}{tmp/lpp.num}{c++}

\lst{hpp.hpp}{tmp/hpp.num}{c++}

\secup
\secup
